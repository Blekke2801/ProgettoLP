;; compare_list/2
;; compares two lists for equality
(defun compare-list (list1 list2)
  (cond ((null list1) t)
        ((null list2) nil)
        ((member (car list1) list2)
         (compare-list (cdr list1) list2))
        (t nil)))


;; trim elimina tot elementi allinizio di una lista utlizzando l'append
(defun trim (list n result)
  (let ((p (make-list n)))
    (append p result list)))


(defun subobj (list object)
  (cond ((null list) '())
        ((eq (car list) '{')
         (let ((sub '()))
           (subobj (cdr list) sub)
           (let ((new-object (cons (cons '{' sub) object)))
             (subobj (cdr sub) new-object))))
        ((eq (car list) '[')
         (let ((sub '()))
           (subarray (cdr list) sub)
           (let ((new-object (cons (cons '[' sub) object)))
             (subobj (cdr sub) new-object))))
        ((eq (car list) '}) (cons '}' object))
        (t (let ((new-object (cons (car list) object)))
             (subobj (cdr list) new-object)))))

(defun subarray (list object)
  (cond ((null list) '())
        ((eq (car list) '[')
         (let ((sub '()))
           (subarray (cdr list) sub)
           (let ((new-object (cons (cons '[' sub) object)))
             (subarray (cdr sub) new-object))))
        ((eq (car list) '{')
         (let ((sub '()))
           (subobj (cdr list) sub)
           (let ((new-object (cons (cons '{' sub) object)))
             (subarray (cdr sub) new-object))))
        ((eq (car list) ']') (cons ']' object))
        (t (let ((new-object (cons (car list) object)))
             (subarray (cdr list) new-object)))))


;; unify
;; converts a list of characters into a single string
(defun unify (a b)
  (cond ((null a) (null b))
        ((eq (car a) '\")
         (let ((ns (unifyquotes (cdr a))))
           (let ((int (+ (length ns) 2)))
             (let ((new-a (trim (cons '\" a) int))))
               (let ((string (coerce ns 'string)))
                 (unify (append (list string) new-a) b)))))
        ((and (not (numberp (car a))) (ignore-errors (atom-number (car a))))
         (let ((ns (unifynumbers a)))
           (let ((int (length ns)))
             (let ((new-a (trim a int)))
               (let ((number (coerce ns 'integer)))
                 (unify (append (list number) new-a) b)))))
        (t (let ((new-b (cons (car a) b)))
             (unify (cdr a) new-b)))))

(defun unifyquotes (a)
  (cond ((eq (car a) '\") '())
        (t (cons (car a) (unifyquotes (cdr a))))))

(defun unifynumbers (a)
  (cond ((and (not (null a)) (ignore-errors (atom-number (car a))))
         (cons (car a) (unifynumbers (cdr a))))
        ((eq (car a) '.') (cons (car a) (unifynumbers (cdr a))))
        (t '())))



(defun jsonparse (jsonstring &optional (result '()))
  (cond ((equal jsonstring "")
          (list 'null))
        ((equal jsonstring "")
          (list 'null))
        ((and (equal (car jsonstring) ?{)
              (equal (cadr jsonstring) ?}))
          (list))
        ((and (equal (car jsonstring) ?[)
              (equal (cadr jsonstring) ?]))
          (list))
        ((stringp jsonstring)
          (let ((chars (coerce jsonstring 'list))
                (xd (delete #\tab chars))
                (xe (delete #\space xd))
                (xf (delete #\newline xe)))
            (cond ((equal (car xf) ?{))
                  ((equal (car xf) ?[))
                  (t (error "Invalid JSON string"))))
            (jsonparse (cons (car xf) xf) result)))
        ((listp jsonstring)
          (let ((chars jsonstring)
                (xd (delete #\tab jsonstring))
                (xe (delete #\space xd))
                (xf (delete #\newline xe)))
            (cond ((equal (car xf) ?{))
                  ((equal (car xf) ?[))
                  (t (error "Invalid JSON string"))))
            (jsonparse (cons (car xf) xf) result)))
        ((and (equal (car jsonstring) ?{)
              (stringp (cadr jsonstring)))
          (let ((attr (cadr jsonstring))
                (val (caddr jsonstring)))
            (cond ((or (stringp val)
                       (numberp val))
                    (jsonparse (list #\{ attr #\: val #\} (cdddr jsonstring))
                               (append result (list (list attr val))))))
            (error "Invalid JSON object")))
        ((and (equal (car jsonstring) ?{)
              (equal (cadr jsonstring) ?{))
          (let ((attr (cadr jsonstring)))
            (jsonparse (cons #\{ (cdr jsonstring)) subresult)
            (jsonparse (list #\{ attr #\: (list 'jsonobj (list subresult)) #\} (cdr subresult))
                       (append result (list (list attr (list 'jsonobj (list subresult))))))))
        ((and (equal (car jsonstring) ?{)
              (equal (cadr jsonstring) ?[))
          (let ((attr (cadr jsonstring)))
            (jsonparse (cons #\{ (cdr jsonstring)) subresult)
            (jsonparse (list #\{ attr #\: (list 'jsonarray (list subresult)) #\} (cdr subresult))
                       (append result (list (list attr (list 'jsonarray (list subresult))))))))
        ((and (equal (car jsonstring) ?[)
              (stringp (cadr jsonstring)))
          (jsonparse (list (cadr jsonstring) (cddr jsonstring))
                     (append result (list (cadr jsonstring))))))
        ((and (equal (car jsonstring) ?[)
              (equal (cadr jsonstring) ?{))
          (jsonparse (cons #\{ (cdr jsonstring)) subresult)
          (jsonparse (list (list 'jsonobj (list subresult)) (cddr subresult))
                     (append result (list (list 'jsonobj (list subresult)))))))
        ((and (equal (car jsonstring) ?[)
              (equal (cadr jsonstring) ?[))
          (json
